{% load static %}
<div class="cc_slider">
  <div class="cc_track" id="cafeSlider">
    {% for cafe in cafes %}
      {% with name=cafe.crawled_store_name|default:cafe.public_store_name %}
      {% with address=cafe.address|default:"" %}
      {% with q=name|add:" "|add:address %}
        <a class="cc_card"
           href="https://map.naver.com/v5/search/{{ q|urlencode }}"
           target="_blank" rel="noopener noreferrer" referrerpolicy="no-referrer"
           style="text-decoration:none; color:inherit; display:block;">
           
          <img class="cc_card_img"
               src="{% static 'css/image/SEOSEONG-IDA.png' %}"
               alt="{{ name }}"
               loading="lazy" decoding="async" fetchpriority="low"
               {% if cafe.google_photo_url %}
                 data-final="{{ cafe.google_photo_url }}"
               {% else %}
                 data-fetch="{% url 'cafe_photo_api' cafe.pk %}"
               {% endif %}
          />

          <h3 class="cc_card_title">{{ name }}</h3>
          <p class="cc_card_address">{{ address }}</p>
          <p class="cc_card_rating">★ {{ cafe.rating|default:"-" }}</p>
        </a>
      {% endwith %}
      {% endwith %}
      {% endwith %}
    {% empty %}
      <p>추천 카페가 없습니다.</p>
    {% endfor %}
  </div>

  <button class="cc_nav cc_prev" type="button">‹</button>
  <button class="cc_nav cc_next" type="button">›</button>
</div>

<script>
(function () {
  const track = document.getElementById('cafeSlider');
  if (!track) return;

  /* =========================
   * A) 이미지 비동기 교체
   * ========================= */
  const imgs = track.querySelectorAll('img.cc_card_img');
  imgs.forEach((img, i) => {
    const direct = img.dataset.final;    // 캐시 있음 → 즉시
    const endpoint = img.dataset.fetch;  // 캐시 없음 → API
    if (direct) { img.src = direct; return; }
    if (!endpoint) return;
    setTimeout(() => {
      fetch(endpoint, { cache: 'no-store' })
        .then(r => r.ok ? r.json() : Promise.reject())
        .then(d => { if (d && d.url) img.src = d.url; })
        .catch(() => {});
    }, i * 120); // 호출 분산
  });

  /* =========================
   * B) 무한 캐러셀 구성
   *  - 원본 카드 세트를 양쪽에 1회씩 복제
   *  - 시작 스크롤을 '중간 세트'로 위치
   *  - 끝/처음 넘어가면 순간 점프(부드러운 이동 유지)
   * ========================= */

  const originalCards = Array.from(track.querySelectorAll('.cc_card'));
  const N = originalCards.length;
  if (!N) return;

  // 1) 앞/뒤로 한 세트씩 복제
  const fragHead = document.createDocumentFragment();
  const fragTail = document.createDocumentFragment();
  originalCards.forEach(card => fragTail.appendChild(card.cloneNode(true)));
  originalCards.slice().reverse().forEach(card => fragHead.insertBefore(card.cloneNode(true), fragHead.firstChild));
  track.insertBefore(fragHead, track.firstChild);
  track.appendChild(fragTail);

  // 2) 인덱스/참조 갱신
  function allCards(){ return Array.from(track.querySelectorAll('.cc_card')); }
  let cards = allCards();
  const MID_START = N;                 // 중간 세트 시작 인덱스
  const MID_END   = N * 2;             // 중간 세트 끝 이전 인덱스

  // 3) 중간 세트의 시작 위치로 점프
  function jumpToMiddleSameOffset() {
    withoutSmooth(() => {
      cards = allCards(); // 리사이즈 후 다시 참조
      const startX = cards[MID_START].offsetLeft;
      track.scrollLeft = startX;
      // widthOriginal: 중간 세트 전체 폭 (오른쪽 복제 세트 시작점 - 중간 세트 시작점)
      widthOriginal = cards[MID_END].offsetLeft - cards[MID_START].offsetLeft;
      step = getStep(); // 카드 폭+gap 재계산
    });
  }

  // 4) 부드러움 유지하며 순간 점프할 때 scroll-behavior 임시 해제
  function withoutSmooth(fn){
    const prev = track.style.scrollBehavior;
    track.style.scrollBehavior = 'auto';
    fn();
    track.style.scrollBehavior = prev || '';
  }

  // 5) gap과 step(카드+gap)을 반응형으로 계산
  function cssGap(){
    const cs = getComputedStyle(track);
    const g = parseFloat(cs.columnGap || cs.gap);
    return Number.isFinite(g) ? g : 24;
  }
  function getStep(){
    const card = track.querySelector('.cc_card');
    if (!card) return 340;
    return card.getBoundingClientRect().width + cssGap();
  }

  // 초기 폭 정보
  let widthOriginal = 0;
  let step = getStep();
  // 첫 배치
  jumpToMiddleSameOffset();

  // 6) 끝/처음 넘어갔는지 점검하여 가운데로 재정렬
  function normalizeInfinite() {
    const midStartX = cards[MID_START].offsetLeft;
    const midEndX   = cards[MID_END].offsetLeft; // 중간 세트 끝 다음(=오른쪽 복제 시작)
    // 왼쪽 클론 세트로 넘어감 → 오른쪽으로 동일 거리 점프
    if (track.scrollLeft < midStartX) {
      withoutSmooth(() => { track.scrollLeft += widthOriginal; });
    }
    // 오른쪽 클론 세트로 넘어감 → 왼쪽으로 동일 거리 점프
    else if (track.scrollLeft >= midEndX) {
      withoutSmooth(() => { track.scrollLeft -= widthOriginal; });
    }
  }

  // 스크롤 시 경계 넘었는지 확인
  track.addEventListener('scroll', normalizeInfinite, { passive: true });

  // 7) 자동 슬라이드(기존 로직 유지, 무한에 맞게 normalize 동작)
  let timer = null;
  const INTERVAL = 3000;
  function goNext() {
    normalizeInfinite();
    track.scrollBy({ left: step, behavior: 'smooth' });
  }
  function start(){ stop(); timer = setInterval(goNext, INTERVAL); }
  function stop(){ if (timer){ clearInterval(timer); timer = null; } }

  track.addEventListener('mouseenter', stop);
  track.addEventListener('mouseleave', start);
  start();

  // 8) 버튼/키보드
  const prevBtn = document.querySelector('.cc_prev');
  const nextBtn = document.querySelector('.cc_next');
  prevBtn?.addEventListener('click', () => {
    normalizeInfinite();
    track.scrollBy({ left: -step, behavior: 'smooth' });
  });
  nextBtn?.addEventListener('click', goNext);
  prevBtn?.addEventListener('keydown', e => { if (e.key === 'Enter') prevBtn.click(); });
  nextBtn?.addEventListener('keydown', e => { if (e.key === 'Enter') nextBtn.click(); });

  // 9) 반응형 대응: 리사이즈 시 폭/오프셋 재계산해서 중간 세트로 재정렬
  let resizeTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(jumpToMiddleSameOffset, 150);
  });
})();
</script>